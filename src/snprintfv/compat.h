/*  -*- Mode: C -*-
 * --------------------------------------------------------------------
 * DO NOT EDIT THIS FILE!  It has been automatically generated
 * from:    configure.in and compat.h.in
 * on host: Werners-MacBook-Pro.local
 * --------------------------------------------------------------------
 * compat.h --- portability code generated for snprintfv by configure.in
 */

#ifndef SNPRINTFV_COMPAT_H
#define SNPRINTFV_COMPAT_H 1

#ifdef __cplusplus
extern "C" {
#if 0
/* This brace is so that emacs can still indent properly: */ }
#endif
#endif /* __cplusplus */

#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <limits.h>
#include <stdarg.h>
#include <sys/types.h>
#include <string.h>
#include <inttypes.h>
#include <wchar.h>
#define SNV_INLINE static inline
typedef wchar_t snv_wchar_t;
typedef unsigned int snv_wint_t;
typedef long double snv_long_double;
#define SNV_FPUTC_UNLOCKED fputc
#define SNV_PUTC_UNLOCKED putc
#define SNV_WITH_LOCKED_FP(fp, tmp_var) \
  for (tmp_var = 1; tmp_var--; )

/* Define macros for storing integers inside pointers.
 * Be aware that it is only safe to use these macros to store `int'
 * values in `char*' (or `void*') words, and then extract them later.
 * Although it will work the other way round on many common
 * architectures, it is not portable to assume a `char*' can be
 * stored in an `int' and extracted later without loss of the msb's
 */

#define SNV_POINTER_TO_INT(p)	((long)(p))
#define SNV_POINTER_TO_UINT(p)	((unsigned long)(p))
#define SNV_INT_TO_POINTER(i)	((snv_pointer)(long)(i))
#define SNV_UINT_TO_POINTER(u)	((snv_pointer)(unsigned long)(u))


/* inline and const keywords are (mostly) handled by config.h */
#ifdef __GNUC__
#  ifndef const
#    define const	__const
#  endif
#  ifndef signed
#    define signed	__signed
#  endif
#  ifndef volatile
#    define volatile	__volatile
#  endif
#else
#  ifndef __STDC__
#    undef  signed
#    define signed
#    undef  volatile
#    define volatile
#  endif
#endif

#ifdef __STDC__
#  ifndef _STR
#    define _STR(x)		#x
#  endif
#  ifndef _CONC
#    define _CONC(x, y)	x##y
#  endif
typedef void *snv_pointer;
typedef const void *snv_constpointer;
#else
#  ifndef _STR
#    define _STR(x)		"x"
#  endif
#  ifndef _CONC
#    define _CONC(x, y)	x/**/y
#  endif
typedef char *snv_pointer;
typedef char *snv_constpointer;
#endif

/* If FALSE is defined, we presume TRUE is defined too.  In this case,
   merely typedef boolean as being int.  Or else, define these all.  */
#ifndef FALSE
/* Do not use `enum boolean': this tag is used in SVR4 <sys/types.h>.  */
typedef enum
{ FALSE = 0, TRUE = 1 }
compatboolean;
#else
typedef int compatboolean;
#endif
#ifndef boolean
#  define boolean compatboolean
#endif

#if defined __CYGWIN32__
#  ifndef __CYGWIN__
#     define __CYGWIN__
#  endif
#endif
#if defined __CYGWIN__ || defined __MSVCRT__ || defined WIN32 || defined __WIN32__
#  ifndef _WIN32
#    define _WIN32
#  endif
#endif

#ifndef EXIT_SUCCESS
#  define EXIT_SUCCESS  0
#  define EXIT_FAILURE  1
#endif

#undef SNV_STMT_START
#undef SNV_STMT_END
#if defined (__GNUC__) && !defined (__STRICT_ANSI__) && !defined (__cplusplus)
#  define SNV_STMT_START	(void)(
#  define SNV_STMT_END		)
#else
#  if (defined (sun) || defined (__sun__))
#    define SNV_STMT_START	if (1)
#    define SNV_STMT_END	else (void)0
#  else
#    define SNV_STMT_START	do
#    define SNV_STMT_END	while (0)
#  endif
#endif

#ifdef _WIN32
#  ifdef DLL_EXPORT
#    define SNV_SCOPE	extern __declspec(dllexport)
#  else
#    ifdef LIBSNPRINTFV_DLL_IMPORT
#      define SNV_SCOPE	extern __declspec(dllimport)
#    endif
#  endif
#endif
#ifndef SNV_SCOPE
#  define SNV_SCOPE	extern
#endif

#undef SNV_GNUC_PRINTF
#undef SNV_GNUC_NORETURN
#if	__GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)
#  define SNV_GNUC_PRINTF( args, format_idx, arg_idx )		\
  	args __attribute__((format (printf, format_idx, arg_idx)))
#  define SNV_GNUC_NORETURN						\
	__attribute__((noreturn))
#  define SNV_ASSERT_FMT  	 " (", __PRETTY_FUNCTION__, ")"
#else /* !__GNUC__ */
#  define SNV_GNUC_PRINTF( args, format_idx, arg_idx ) args
#  define SNV_GNUC_NORETURN
#  define SNV_ASSERT_FMT		"", "", ""
#endif /* !__GNUC__ */

#ifndef STR
#  define STR(s) _STR(s)
#endif

#define snv_assert(expr)			snv_fassert(stderr, expr)
#define snv_fassert(stream, expr)	SNV_STMT_START{			\
    if (!(expr))                         	\
    {                    	                           \
	fprintf (stream, "file %s: line %d%s%s%s: assertion \"%s\" failed.\n", \
	__FILE__, __LINE__, SNV_ASSERT_FMT, _STR(expr));		\
	exit(EXIT_FAILURE);						\
    };					}SNV_STMT_END

#define return_if_fail(expr)		freturn_if_fail(stderr, expr)
#define freturn_if_fail(expr)		SNV_STMT_START{			\
    if (!(expr))							\
    {									\
	fprintf (stream, "file %s: line %d%s%s%s: assertion \"%s\" failed.\n", \
	__FILE__, __LINE__, SNV_ASSERT_FMT, _STR(expr));		\
	return;								\
    };					}SNV_STMT_END

#define return_val_if_fail(expr, val)	freturn_val_if_fail(stderr, expr, val)
#define freturn_val_if_fail(stream, expr, val)	SNV_STMT_START{		\
    if (!(expr))							\
    {									\
	fprintf (stream, "file %s: line %d%s%s%s: assertion \"%s\" failed.\n", \
	__FILE__, __LINE__, SNV_ASSERT_FMT, _STR(expr));		\
	return val;							\
    };					}SNV_STMT_END

#ifndef MAX
#define MAX(a,b)	((a) > (b) ? (a) : (b))
#endif

#ifndef MIN
#define MIN(a,b)	((a) < (b) ? (a) : (b))
#endif

#ifndef ABS
#define ABS(a)		((a) < 0 ? -(a) : (a))
#endif


#ifdef __cplusplus
#if 0
/* This brace is so that emacs can still indent properly: */ {
#endif
}
#endif /* __cplusplus */

#endif /* COMPAT_H */
